// CPEG222 - Lab1 code// Author: Byron Lambrou, Kathryn Black// Input: two on-board buttons: Btn1, Btn2// Output:  PMod8LD: PLed1~PLed8 2xSSDisplays::// There are some questions left for you in the code#include<p32xxxx.h>#include<plib.h>#pragma config FPLLMUL = MUL_20, FPLLIDIV = DIV_2, FPLLODIV = DIV_1, FWDTEN = OFF#pragma config POSCMOD = HS, FNOSC = PRIPLL, FPBDIV = DIV_2// 7 Segment Display pmod using the TOP JA & JB jumpers// Segments#define SegA_R LATEbits.LATE0#define SegB_R LATEbits.LATE1#define SegC_R LATEbits.LATE2#define SegD_R LATEbits.LATE3#define SegE_R LATGbits.LATG9#define SegF_R LATGbits.LATG8#define SegG_R LATGbits.LATG7// Display selection. 0 = right, 1 = left (Cathode)#define DispSel_R LATGbits.LATG6// 7 Segment Display pmod using the TOP JC and JD jumpers#define SegA_L LATGbits.LATG12#define SegB_L LATGbits.LATG13#define SegC_L LATGbits.LATG14#define SegD_L LATGbits.LATG15#define SegE_L LATDbits.LATD7#define SegF_L LATDbits.LATD1#define SegG_L LATDbits.LATD9// Display selection. 0 = right, 1 = left (Cathode)#define DispSel_L LATCbits.LATC1// Define Pmod LDs as PLed1~PLed8 (JE jumper)#define PLed1   LATDbits.LATD14#define PLed2   LATDbits.LATD15#define PLed3   LATFbits.LATF2#define PLed4   LATFbits.LATF8#define PLed5   LATDbits.LATD13#define PLed6   LATDbits.LATD3#define PLed7   LATDbits.LATD11#define PLed8   LATCbits.LATC3//Define buttons 1 and 2#define Btn1	PORTAbits.RA6#define Btn2	PORTAbits.RA7//We will use Btn1 as the left player paddle//And Btn2 as right player paddleenum Mode {left,right};enum Mode mode=left;unsigned int button_press_on=0;unsigned int buttonLock1=0;unsigned int buttonLock2=0;unsigned int i = 0;unsigned int score_left=0;unsigned int score_right=0;unsigned int left_ssd_flip=0;unsigned int miss=0;unsigned int served=0;unsigned int state=1;unsigned int display_number = 0;unsigned int time_to_hit=0;//	0-9 numbersunsigned char SSD_number[]={0b0111111,	//00b0000110,	//10b1011011,	//20b1001111,	//30b1100110,	//40b1101101,	//50b1111101,	//60b0000111,	//70b1111111,	//80b1101111,	//90b0000000,	//clear};void displayDigit (unsigned char value, unsigned int left_ssd, unsigned int leftdisp){//For left=1, display on left SSD, else, on right SSD	if(left_ssd==1){		if(leftdisp==1){			SegA_L = value & 1;			SegB_L = (value >> 1) & 1;			SegC_L = (value >> 2) & 1;			SegD_L = (value >> 3) & 1;			SegE_L = (value >> 4) & 1;			SegF_L = (value >> 5) & 1;			SegG_L = (value >> 6) & 1;			DispSel_L= 0;		}		else{			SegA_L = value & 1;			SegB_L = (value >> 1) & 1;			SegC_L = (value >> 2) & 1;			SegD_L = (value >> 3) & 1;			SegE_L = (value >> 4) & 1;			SegF_L = (value >> 5) & 1;			SegG_L = (value >> 6) & 1;			DispSel_L= 1;		}			}	else{		if(leftdisp==1){			SegA_R = value & 1;			SegB_R = (value >> 1) & 1;			SegC_R = (value >> 2) & 1;			SegD_R = (value >> 3) & 1;			SegE_R = (value >> 4) & 1;			SegF_R = (value >> 5) & 1;			SegG_R = (value >> 6) & 1;			DispSel_R= 0;		}		else{			SegA_R = value & 1;			SegB_R = (value >> 1) & 1;			SegC_R = (value >> 2) & 1;			SegD_R = (value >> 3) & 1;			SegE_R = (value >> 4) & 1;			SegF_R = (value >> 5) & 1;			SegG_R = (value >> 6) & 1;			DispSel_R= 1;		}			}}void showNumber(int digit, unsigned int left_ssd_num, unsigned int leftdisp){    displayDigit(SSD_number[digit%10], left_ssd_num, leftdisp);} void setPmodLed(int value){	// This function will be refered later   PLed1=(value & 0b10000000) >>7;   PLed2=(value & 0b01000000) >>6;   PLed3=(value & 0b00100000) >>5;   PLed4=(value & 0b00010000) >>4;   PLed5=(value & 0b00001000) >>3;   PLed6=(value & 0b00000100) >>2;   PLed7=(value & 0b00000010) >>1;   PLed8=(value & 0b00000001);}void showSSDRightorLeft(){	//left_ssd_flip is inverted by the function of timer 4's interrupt	//since it is constantly being flipped by the interupt, we will write to each	//digit(side) an equal time	if(left_ssd_flip){	  showNumber(score_left/10,1,0);		showNumber(score_right/10,0,0);		}	else{		showNumber(score_left%10,1,1);		showNumber(score_right%10,0,1);	}}int whoServe(unsigned int score_left, unsigned int score_right){	//Function to determine who serves the ball next.	//Returns, according to the services rules, who serves.	//Returns 0x80 if the left player should serve, and	//returns 0x1 if the right player should serve, which correspond to	//the pmod8LED status for each serve case.	//The left player always serves for the first 2 turns, then the right	//player for two turns, until the players both have ten points or more,	//then each player serves the ball for only one point in their turn.	int sum = score_right+score_left;	int to_serve;	if((sum)<20){		if((((sum/2)%2)==0)){			//then left player serves			to_serve=0x80;		}		else{			//then right player serves			to_serve=0x1;		}	}	if((sum)>=20){		if(sum%2==0){			to_serve=0x80;		}		else{			to_serve=0x1;		}	}	return to_serve;}int isWin( unsigned int score_left, unsigned int score_right){  //Function to decide if one of the players has won the game.  //The rule for winning is as follows  //If either player has a score of 11, and the other player has a score of <10,  //this player wins the game.  //If both players have a score of 10 or more, then if either player has a score  //which is 2 points greater than the other, they win the game.  //Return 0 if neither player has won, 1 if left side has won, 2 if right side has won  int decision=0;  if (score_left<11 && score_right<11){	decision=0;  }  if(score_left==11 && score_right<10){	decision=1;  }  if(score_right==11 && score_left<10){    decision=2;  }  if (score_left>=10 && score_right>=10){    if((score_left-2)>=score_right){	    decision=1;	  }	  else if((score_right-2)>=score_left){	    decision=2;	  }	  else{	    decision=0;	  }  }  return decision;}// Handler of timer interrupt. It performs shift.  void __ISR(_TIMER_5_VECTOR, ipl4) _T5Interrupt(void){	// perform shift	if(state==3 || state==4){    display_number = (state==4)? display_number<<1: display_number>>1;    if (display_number==0 && state==3) // if we shift past this, then the player missed		miss=1;    if (display_number>=0x90 && state==4) // if we shift past this, then the player missed		miss=1;  }	IFS0CLR = 0x100000;   // Clear Timer5 interrupt status flag (bit 20)}void __ISR(_TIMER_4_VECTOR, ipl4) _T4Interrupt(void){	//This timer interrupt controls the speed at which we flip between the different sides of the pmod  left_ssd_flip=!left_ssd_flip;	IFS0bits.T4IF = 0;   // Clear Timer4 interrupt status flag}main(){        //Configure port A for input on 6 and 7        TRISA = 0xC0;        //Configure ports C~G to be output ports	TRISC = 0;		TRISD = 0;	TRISE = 0;	TRISF = 0;	TRISG = 0;	// initialize C~G to 0	PORTC = 0x00;		PORTD = 0x00;		PORTE = 0x00;		PORTF = 0x00;		PORTG = 0x00;        // Configure Timer 5.	T5CON = 0x0; // Stop timer, clear control registers	TMR5 = 0x0; // Timer counter	PR5 = 0xC000; //Timer count amount for interupt to occur	IPC5SET = 0x0010; //prioirty 4	IFS0CLR = 0x100000; // clear interrupt flag	IEC0SET = 0x100000; //enable Timer 5	T5CON = 0x0070;  // prescaler at 1:256, internal clock sourc	T5CONSET = 0x8000;  // Timer 5 module is enabled        //Configure Timer 4	T4CONbits.ON=0; //Turn Timer 4 off	TMR4=0; //Clear Timer 4 register	T4CONbits.TCKPS=3; //Select prescaler = 256	T4CONbits.TCS=0; //Select internal clock	PR4=901250; //Load period Register	IFS0bits.T4IF=0; //Clear Timer 4 interupt flag	IPC4bits.T4IP=4; //Set priority level to 4	IEC0bits.T4IE=1; // Enable Timer 4	T4CONbits.ON=1; //Turn Timer  4 on.	INTEnableSystemMultiVectoredInt();while(1){       /* Current State Logic */  if(state==1){    //Mode 1 is the waiting for a player to press a button    //During this mode, the scores from the previous game should be displayed    showSSDRightorLeft();  }  if(state==2){            //determines who should serve    setPmodLed(display_number);    showSSDRightorLeft();  }  if(state==3){    //Ball moves from left to right    setPmodLed(display_number);    showSSDRightorLeft();  }  if(state==4){            //Ball moves from right to left    setPmodLed(display_number);    showSSDRightorLeft();  }  if(state==5){            //Check if a player has won the game and act accordingly    setPmodLed(display_number);    showSSDRightorLeft();  }       /* Next State Logic */  if(state==1){            //If mode=1, do nothing unless a button is pressed    if (Btn1 && !buttonLock1) { // Check button status      buttonLock1 = 1;      while (i < 10000){i++;};       i=0;      state=2;      score_right=0;      score_left=0;      }    if (Btn2 && !buttonLock2) { // Check button status      buttonLock2 = 1;      while (i < 10000){i++;};      i=0;      state=2;      score_right=0;      score_left=0;      }    }  else if(state==2){  	display_number=whoServe(score_left,score_right);  	if(display_number==0x80){  		if (Btn1 && !buttonLock1) { // Check button status      	buttonLock1 = 1;      	while (i < 10000){i++;};      	state=3;      	miss=0;      }  	}  	else{  		 if (Btn2 && !buttonLock2) { // Check button status      	buttonLock2 = 1;      	while (i < 10000){i++;};      	state=4;      	miss=0;      }  	}  }  else if(state==3){  	//in this mode, we will only check for btn2 presses	  if (Btn2 && !buttonLock2) { // Check button status    	buttonLock2 = 1;    	while (i < 10000){i++;};  		if(display_number==0x1){  			state=4;  			miss=0;  		}  		else{  			score_left++;  			state=5;  		}    }    if(miss){    	score_left++;    	miss=0;    	state=5;    }  }  else if(state==4){  	if (Btn1 && !buttonLock1) { // Check button status    	buttonLock1 = 1;    	while (i < 10000){i++;};  		if(display_number==0x80){  			state=3;  			miss=0;  		}  		else{  			score_right++;  			state=5;  		}    }    if(miss){    	score_right++;    	miss=0;    	state=5;    }  }  else if(state==5){  	if(!isWin(score_left,score_right)){  		state=2;  	}  	else{  		display_number=0;  		setPmodLed(display_number);  		state=1;  	}  }  if (!Btn1 && buttonLock1) { // Check button status      buttonLock1 = 0;      while (i < 10000){i++;};      i=0;  }  if (!Btn2 && buttonLock2) { // Check button status      buttonLock2 = 0;      while (i < 10000){i++;};      i=0;  }  }//End of While loop}